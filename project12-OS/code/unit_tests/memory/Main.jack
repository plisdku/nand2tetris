// Minimal unit tests for Memory
class Main {

    function void main() {
        /* do not uncomment the commented tests here. */

        // do Output.printString("Hello, world");
        // do Output.println();
        do Main.testResetLayout(); // expected: OK
        do Main.testAllocSingleCheck(); // expected: OK
        do Main.testAllocWhole();      // expected: OK
        do Main.testAllocTooBig();     // expected: OK (error)
        do Main.testAllocMaxSegments();
        do Main.testDumpSegments();
        do Main.testDealloc();
        // do Main.testFindSegmentLoop(); // expected: error message
        return;
    }


        // Verify Memory.init() establishes the expected initial heap layout.
        function void testResetLayout() {
            var int a0, a1, a2, a3, ok;

            do Memory.init();

            // Inspect first four words of heap
            // Expect:
            // ram[2048] = -1        (dummy node)
            // ram[2049] = 2050      (dummy.next -> first real node)
            // ram[2050] = 14334     (first real node length = total available - 2)
            // ram[2051] = -1        (first real node next)

            let a0 = Memory.peek(2048);
            let a1 = Memory.peek(2048+1);
            let a2 = Memory.peek(2048+2);
            let a3 = Memory.peek(2048+3);

            let ok = 0;
            // Expect: -1, 2048+2, (16384-2048)-2, -1
            if ((a0 = -1) & (a1 = 2050) & (a2 = 14334) & (a3 = -1)) {
                let ok = 1;
            }

            // Reset heap so Output can allocate
            do Memory.init();

            do Output.printString("testResetLayout: ");
            if (ok = 1) {
                do Output.printString("OK");
            } else {
                do Output.printString("FAIL");
            }
            do Output.println();
            return;
        }

    // Allocate a single block and verify free-list head and first real node look sane.
    // No printing until after Memory.init() resets the heap.
    function void testAllocSingleCheck() {
        var int p, a0, a1, a2, a3, a4, ok;

        // initialize heap
        do Memory.init();

        // allocate one moderate block
        let p = Memory.alloc(100);

        // Expected state (correct split behavior):
        // ram[2048] = -1        (dummy node)
        // ram[2049] = 2152      (dummy.next -> new free segment at found+2+size)
        // ram[2050] = 102       (found.header = allocated total = size+2)
        // ram[2152] = 14232     (new free segment length = original_len - size - 2)
        // ram[2153] = -1        (new.next = -1)

        let ok = 0; // fail until checks pass
        if (~(p = -1)) {
            let a0 = Memory.peek(2048);
            let a1 = Memory.peek(2049);
            let a2 = Memory.peek(2050);
            let a3 = Memory.peek(2152);
            let a4 = Memory.peek(2153);

            if ((a0 = -1) & (a1 = 2152) & (a2 = 102) & (a3 = 14232) & (a4 = -1)) {
                let ok = 1;
            }
        }

        // Reset memory so Output can allocate
        do Memory.init();

        do Output.printString("testAllocSingleCheck: ");
        if (ok = 1) {
            do Output.printString("OK");
        } else {
            do Output.printString("FAIL");
            do Output.println();
            do Output.printInt(a0);
            do Output.println();
            do Output.printInt(a1);
            do Output.println();
            do Output.printInt(a2);
            do Output.println();
            do Output.printInt(a3);
            do Output.println();
            do Output.printInt(a4);
        }
        do Output.println();
        return;
    }

    function void testAllocWhole() {
        var int p;
        do Memory.init();
        let p = Memory.alloc(14330); // attempt to allocate nearly whole heap
        // Deallocate before printing: Output may need heap space
        if (p = -1) {
            do Output.printString("testAllocWhole: FAIL");
            do Output.println();
        } else {
            do Memory.deAlloc(p);
            do Output.printString("testAllocWhole: OK");
            do Output.println();
        }
        do Output.println();
        return;
    }

    function void testAllocTooBig() {
        var int p;
        do Memory.init();
        let p = Memory.alloc(20000);
        do Output.printString("testAllocTooBig: ");
        if (p = -1) {
            do Output.printString("OK");
        } else {
            do Output.printString("FAIL");
            do Memory.deAlloc(p);
        }
        do Output.println();
        return;
    }

    // Allocate minimal blocks until failure and print count
    function void testAllocMaxSegments() {
        var int p, count, expected;
        // Explanation: initial free words = heap_size - 2 = 14334.
        // Each allocation of size 1 consumes 1 data + 2 header = 3 words.
        // Expected number of allocations = 14334 / 3 = 4778.
        do Memory.init();
        let count = 0;
        let p = Memory.alloc(1);
        while (~(p = -1)) {
            let count = count + 1;
            let p = Memory.alloc(1);
        }
        // Reset memory so Output has heap space for printing
        do Memory.init();
        let expected = 14334 / 3; // 4778
        do Output.printString("testAllocMaxSegments: ");
        if (count = expected) {
            do Output.printString("OK");
        } else {
            do Output.printString("FAIL: got=");
            do Output.printInt(count);
            do Output.printString(",exp=");
            do Output.printInt(expected);
        }
        do Output.println();
        return;
    }

    function void testDumpSegments() {
        do Memory.init();
        do Output.printString("testDumpSegments:");
        do Output.println();
        do Memory.dumpSegments(5);
        return;
    }

    function void testDealloc() {
        var int p1, p2, a0, a1, a2, a3, a4, ok;

        // Succinct expected state after allocating 10, 20 and freeing the first (10):
        // ram[2048] = -1        (dummy)
        // ram[2049] = 2050      (dummy.next -> returned segment header)
        // ram[2050] = 12        (returned segment length = 10 + 2)
        // ram[2051] = 2084      (returned_segment.next -> points to second free chunk)
        // ram[2084] = 14300     (remaining free length)

        do Memory.init();
        let p1 = Memory.alloc(10);
        let p2 = Memory.alloc(20);
        do Memory.deAlloc(p1);

        let ok = 0;
        let a0 = Memory.peek(2048);
        let a1 = Memory.peek(2049);
        let a2 = Memory.peek(2050);
        let a3 = Memory.peek(2051);
        let a4 = Memory.peek(2084);

        if ((a0 = -1) & (a1 = 2050) & (a2 = 12) & (a3 = 2084) & (a4 = 14300)) {
            let ok = 1;
        }

        // Reset memory so Output can allocate
        do Memory.init();

        do Output.printString("testDealloc: ");
        if (ok = 1) {
            do Output.printString("OK");
        } else {
            do Output.printString("FAIL:");
            do Output.printString(" a0="); do Output.printInt(a0);
            do Output.printString(" a1="); do Output.printInt(a1);
            do Output.printString(" a2="); do Output.printInt(a2);
            do Output.printString(" a3="); do Output.printInt(a3);
            do Output.printString(" a4="); do Output.printInt(a4);
        }
        do Output.println();
        return;
    }

        // Force a split and verify the new free segment is placed after allocated block.
        // Do not print until heap is reset.
        function void testSplitPlace() {
            var int p, header, first, orig_len, next_of_alloc, new_free_len, ok, allocated_total;

            do Memory.init();

            // inspect first real node
            let first = Memory.peek(2048+1);
            let orig_len = Memory.peek(first);

            // pick a size that should force a split
            let p = Memory.alloc(100);

            let ok = 0; // fail until checks pass

            if (~(p = -1)) {
                let header = p - 2;
                let next_of_alloc = Memory.peek(header+1);
                if (~(next_of_alloc = -1)) {
                    let new_free_len = Memory.peek(next_of_alloc);
                    // allocated header now stores allocated total (size+2)
                    let allocated_total = Memory.peek(header);
                    if ((next_of_alloc > header) & (new_free_len > 0) & (new_free_len + allocated_total = orig_len)) {
                        let ok = 1;
                    }
                }
            }

            // reset heap so Output can allocate
            do Memory.init();

            do Output.printString("testSplitPlace: ");
            if (ok = 1) {
                do Output.printString("OK");
            } else {
                do Output.printString("FAIL");
            }
            do Output.println();
            return;
        }

        // Optional diagnostic: create a simple self-cycle in the free list and
        // call find_segment to reproduce an infinite-loop condition. Not called
        // by default; uncomment in `main` if you want to reproduce locally.
        function void testFindSegmentLoop() {
            var int first;

            do Memory.init();

            // first real node address
            let first = Memory.peek(2048+1);

            // make the node have a small length so the search will enter the
            // while-loop and iterate the free list
            do Memory.poke(first, 1);
            // make the node point to itself (cycle)
            do Memory.poke(first+1, first);

            // This should trigger the iteration guard and call Sys.error
            // Use a requested size larger than the node length to force traversal
            do Memory.find_segment(2048, 100);

            // If we get here, the guard didn't trigger
            do Memory.init();
            do Output.printString("testFindSegmentLoop: FAIL (no error)");
            do Output.println();
            return;
        }


}
