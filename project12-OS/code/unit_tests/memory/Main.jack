// Minimal unit tests for Memory
class Main {

    function void main() {
        /* do not uncomment the commented tests here. */

        // do Output.printString("Hello, world");
        // do Output.println();
        // do Main.testResetLayout(); // expected: OK
        do Main.testAllocSingleCheck(); // expected: OK
        // do Main.testAllocWhole();      // expected: OK
        // do Main.testAllocTooBig();     // expected: OK (error)
        // do Main.testAllocMaxSegments();
        // do Main.testDumpSegments();
        //do Main.testDealloc();
        return;
    }


        // Verify Memory.init() establishes the expected initial heap layout.
        function void testResetLayout() {
            var int a0, a1, a2, a3, ok;

            do Memory.init();

            // Inspect first four words of heap
            // Expect:
            // ram[2048] = -1        (dummy node)
            // ram[2049] = 2050      (dummy.next -> first real node)
            // ram[2050] = 14334     (first real node length = total available - 2)
            // ram[2051] = -1        (first real node next)

            let a0 = Memory.peek(2048);
            let a1 = Memory.peek(2048+1);
            let a2 = Memory.peek(2048+2);
            let a3 = Memory.peek(2048+3);

            let ok = 0;
            // Expect: -1, 2048+2, (16384-2048)-2, -1
            if ((a0 = -1) & (a1 = 2050) & (a2 = 14334) & (a3 = -1)) {
                let ok = 1;
            }

            // Reset heap so Output can allocate
            do Memory.init();

            do Output.printString("testResetLayout: ");
            if (ok = 1) {
                do Output.printString("OK");
            } else {
                do Output.printString("FAIL");
            }
            do Output.println();
            return;
        }

    // Allocate a single block and verify free-list head and first real node look sane.
    // No printing until after Memory.init() resets the heap.
    function void testAllocSingleCheck() {
        var int p, a0, a1, a2, a3, a4, ok;

        // initialize heap
        do Memory.init();

        // allocate one moderate block
        let p = Memory.alloc(100);

        // Expected state (correct split behavior):
        // ram[2048] = -1        (dummy node)
        // ram[2049] = 2152      (dummy.next -> new free segment at found+2+size)
        // ram[2050] = 102       (found.header = allocated total = size+2)
        // ram[2152] = 14232     (new free segment length = original_len - size - 2)
        // ram[2153] = -1        (new.next = -1)

        let ok = 0; // fail until checks pass
        if (~(p = -1)) {
            let a0 = Memory.peek(2048);
            let a1 = Memory.peek(2049);
            let a2 = Memory.peek(2050);
            let a3 = Memory.peek(2152);
            let a4 = Memory.peek(2153);

            if ((a0 = -1) & (a1 = 2152) & (a2 = 102) & (a3 = 14232) & (a4 = -1)) {
                let ok = 1;
            }
        }

        // Reset memory so Output can allocate
        do Memory.init();

        do Output.printString("testAllocSingleCheck: ");
        if (ok = 1) {
            do Output.printString("OK");
        } else {
            do Output.printString("FAIL");
            do Output.println();
            do Output.printInt(a0);
            do Output.println();
            do Output.printInt(a1);
            do Output.println();
            do Output.printInt(a2);
            do Output.println();
            do Output.printInt(a3);
            do Output.println();
            do Output.printInt(a4);
        }
        do Output.println();
        return;
    }

    function void testAllocWhole() {
        var int p;
        do Memory.init();
        let p = Memory.alloc(14330); // attempt to allocate nearly whole heap
        // Deallocate before printing: Output may need heap space
        if (p = -1) {
            do Output.printString("testAllocWhole: FAIL");
            do Output.println();
        } else {
            do Memory.deAlloc(p);
            do Output.printString("testAllocWhole: OK");
            do Output.println();
        }
        do Output.println();
        return;
    }

    function void testAllocTooBig() {
        var int p;
        do Memory.init();
        let p = Memory.alloc(20000);
        do Output.printString("testAllocTooBig: ");
        if (p = -1) {
            do Output.printString("OK");
        } else {
            do Output.printString("FAIL");
            do Memory.deAlloc(p);
        }
        do Output.println();
        return;
    }

    // Allocate minimal blocks until failure and print count
    function void testAllocMaxSegments() {
        var int p, count;
        do Memory.init();
        let count = 0;
        let p = Memory.alloc(1);
        while (~(p = -1)) {
            let count = count + 1;
            let p = Memory.alloc(1);
        }
        // Reset memory so Output has heap space for printing
        do Memory.init();
        do Output.printString("testAllocMaxSegments: ");
        do Output.printInt(count);
        do Output.println();
        return;
    }

    function void testDumpSegments() {
        do Memory.init();
        do Output.printString("testDumpSegments:");
        do Output.println();
        do Memory.dumpSegments(5);
        return;
    }

    function void testDealloc() {
        var int p1, p2;
        do Memory.init();
        let p1 = Memory.alloc(10);
        let p2 = Memory.alloc(20);
        do Memory.deAlloc(p1);
        do Output.printString("testDealloc: after freeing p1");
        do Output.println();
        do Memory.dumpSegments(5);
        return;
    }

        // Force a split and verify the new free segment is placed after allocated block.
        // Do not print until heap is reset.
        function void testSplitPlace() {
            var int p, header, first, orig_len, next_of_alloc, new_free_len, ok, allocated_total;

            do Memory.init();

            // inspect first real node
            let first = Memory.peek(2048+1);
            let orig_len = Memory.peek(first);

            // pick a size that should force a split
            let p = Memory.alloc(100);

            let ok = 0; // fail until checks pass

            if (~(p = -1)) {
                let header = p - 2;
                let next_of_alloc = Memory.peek(header+1);
                if (~(next_of_alloc = -1)) {
                    let new_free_len = Memory.peek(next_of_alloc);
                    // allocated header now stores allocated total (size+2)
                    let allocated_total = Memory.peek(header);
                    if ((next_of_alloc > header) & (new_free_len > 0) & (new_free_len + allocated_total = orig_len)) {
                        let ok = 1;
                    }
                }
            }

            // reset heap so Output can allocate
            do Memory.init();

            do Output.printString("testSplitPlace: ");
            if (ok = 1) {
                do Output.printString("OK");
            } else {
                do Output.printString("FAIL");
            }
            do Output.println();
            return;
        }


}
