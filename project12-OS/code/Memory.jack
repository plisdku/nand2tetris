class Memory {
    
    static Array ram;
    static int free_list;
    static int free_list_size;
    static int free_list_next;

    static int heap_base;
    static int heap_size;

    function void init() {
        let ram = 0;

        // freeList = heapBase;
        // freeList.size = heapSize;
        // freeList.next = 0;

        let heap_base = 2048;
        let heap_size = 16384 - heap_base;

        do Memory.reset();

        return;
    }

    function void reset() {
        // Put a dummy node of zero length at the start of the free list
        // Heap layout: [dummy_node: 2 words][first_real_node: remaining words]

        let free_list = heap_base;

        // dummy node: length = -1 (never allocatable)
        let ram[free_list] = -1;

        // dummy_node.next = first real node
        let ram[free_list+1] = free_list+2;

        // first real node: length = total available space - dummy node overhead
        // Available space = heap_size - 2 (for dummy node header)
        let ram[free_list+2] = heap_size - 2;
        
        // first real node has no next
        let ram[free_list+3] = -1;

        return;
    }

    function int peek(int address) {
        return ram[address];
    }

    function void poke(int address, int value) {
        let ram[address] = value;
        return;
    }

    function int segment_length(int node) {
        if (node = -1) {
            return -1;
        }
        if ((node < heap_base) | (node > (heap_base + heap_size - 1))) {
            do Sys.error(5001); // "Segment address out of heap bounds"
            return -1;
        }
        return ram[node];
    }

    function int next_segment(int node) {
        if (node = -1) {
            return -1;
        }
        if ((node < heap_base) | (node > (heap_base + heap_size - 1))) {
            do Sys.error(5002); // "Next segment address out of heap bounds"
            return -1;
        }
        return ram[node+1];
    }


    // free_list points to the first block.
    // if we give away the first block, then free_list points to the next one.
    // if we dealloc a block that's before free_list, then free_list points to that.
    // this could be done by having a dummy first node of length zero or something,
    // so it never gets allocated.

    function int find_segment(int cur_node, int size) {

        var int next_node, next_next_node;

        // First available segment heuristic.
        // Return the segment BEFORE the available segment, or -1 if no segment
        // is found.

        let next_node = Memory.next_segment(cur_node);

        while (~(next_node = -1) & (Memory.segment_length(next_node) < size)) {
            let next_next_node = Memory.next_segment(next_node);

            if (next_next_node = -1) {
                return -1;
            }

            let cur_node = next_node;
            let next_node = next_next_node;
        }

        if (next_node = -1) {
            return -1;
        }

        return cur_node;
    }


    function void insert_segment(int before_new, int new, int length) {

        // Bounds checking
        if ((new < heap_base) | (new > (heap_base + heap_size - 1))) {
            do Sys.error(5007); // "Insert segment address out of bounds"
            return;
        }
        
        if ((length < 2) | (length > heap_size)) {
            do Sys.error(5008); // "Insert segment invalid length"
            return;
        }

        // new.next = before_new.next
        let ram[new+1] = ram[before_new+1];

        // new.length = length
        let ram[new] = length;

        // before_new.next = new
        let ram[before_new+1] = new;

        return;
    }


    function void remove_segment(int before_remove_me, int remove_me) {

        // Bounds checking
        if ((remove_me < heap_base) | (remove_me > (heap_base + heap_size - 1))) {
            do Sys.error(5009); // "Remove segment address out of bounds"
            return;
        }

        // before_remove_me.next = remove_me.next
        let ram[before_remove_me+1] = ram[remove_me+1];

        return;
    }

    function Array alloc(int size) {

        var int before_found, found, new, found_length;

        // Input validation
        if (size < 1) {
            do Sys.error(5003); // "Invalid allocation size"
            return -1;
        }

        let before_found = Memory.find_segment(free_list, size);

        if (before_found = -1) {
            do Sys.error(6); // "Heap overflow - no available segment"
            return -1;
        }

        let found = Memory.next_segment(before_found);
        let found_length = Memory.segment_length(found);

        // Can we split this segment?
        // We need: [allocated_block: size + 2][new_free_segment: >= 2]
        // So total needed: size + 2 + 2 = size + 4
        if (found_length > (size + 4)) {

            // Split the segment
            // new segment starts after: segment_header(2) + allocated_data(size)
            let new = found + 2 + size;
            
            // new segment length = original_length - header_size - allocated_size
            do Memory.insert_segment(before_found, new, found_length - size - 2);

            // Update found segment to exact allocation size + header
            let ram[found] = size + 2;

            // Return pointer to data area (skip 2-word header)
            return found + 2;
        }
        else
        {
            // Use entire segment - remove from free list
            do Memory.remove_segment(before_found, found);
            
            // Return pointer to data area (skip 2-word header)
            return found + 2;
        }
    }

    function void deAlloc(Array base) {
        // deallocate the block of memory starting at base.
        // base points to data area, so base-2 points to segment header
            
        var int returned_segment, returned_segment_length, dummy_segment;

        // Input validation
        if (base = 0) {
            do Sys.error(5004); // "Attempted to deallocate null pointer"
            return;
        }

        let returned_segment = base - 2;
        
        // Bounds check
        if ((returned_segment < heap_base) | (returned_segment > (heap_base + heap_size - 1))) {
            do Sys.error(5005); // "Deallocation address out of heap bounds"
            return;
        }

        let returned_segment_length = Memory.segment_length(returned_segment);
        
        // Sanity check segment length
        if ((returned_segment_length < 2) | (returned_segment_length > heap_size)) {
            do Sys.error(5006); // "Invalid segment length in deallocation"
            return;
        }

        let dummy_segment = free_list;

        // Insert after dummy node (simple, avoids fragmentation complexity)
        do Memory.insert_segment(dummy_segment, returned_segment, returned_segment_length);

        return;
    }
}